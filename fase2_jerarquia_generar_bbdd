1. Objetivo de la fase 2

Diseñar la jerarquía de datos y las estructuras finales sobre las que se generarán los datos simulados, garantizando que:
los datos nazcan ya con lógica de negocio, el modelo sea directamente explotable en Power BI, y el sistema sea compatible con predicción y MCP desde el inicio.


2. Arquitectura general
La arquitectura se compone de dos bloques:

1) Data Lake (RAW). Almacenamiento de los datos tal y como vendrían de una API tipo PrestaShop.

2) Data Warehouse en Fabric. Warehouse con tablas Delta.
Contiene: el modelo estrella completo de negocio, la dimensión tiempo única, y las tablas de predicción.
Es el único punto de consumo para: Power BI, MCP , agentes


3. Capa RAW (Data Lake)
Formato: JSON.
Un fichero por ejecución (run) y por endpoint. (se genera un fichero distinto por cada endpoint).
Enfoque append-only. (cada ejecución añade nuevos datos)
Simulación de comportamiento real de API REST.
Cada ejecución queda identificada por: run_id (identificador único de la carga), timestamp de extracción (fecha y hora de extracción), origen (prestashop_simulado)


4. Data Warehouse (Fabric · Delta)
Contenido del DW:
1) Modelo estrella (negocio)
2) Tablas analíticas de predicción
Ventas diarias reales (agregadas).
Ventas diarias forecast.


5. Dimensión tiempo
Generada desde el inicio en el DW.
Única definición temporal para:Power BI,modelos predictivos,MCP. Evita duplicidades y ambigüedades posteriores.


6. Siguiente paso
Definir la jerarquía exacta de carpetas y nombres en RAW,
sobre la que se generarán los datos simulados.


DEFINICIÓN JERARQUÍA DE CARPETAS Y NOMBRES EN RAW

Paso 1: Jerarquía RAW (datalake)

**Raíz**
/raw/prestashop/


**Estructura**
/raw/prestashop/
  _control/
    run_id=<run_id>/
      run_manifest.json
      run_stats.json
      run_errors.json

  orders/ingest_date=YYYY-MM-DD/run_id=<run_id>/orders.json
  customers/ingest_date=YYYY-MM-DD/run_id=<run_id>/customers.json
  products/ingest_date=YYYY-MM-DD/run_id=<run_id>/products.json
  categories/ingest_date=YYYY-MM-DD/run_id=<run_id>/categories.json
  channels/ingest_date=YYYY-MM-DD/run_id=<run_id>/channels.json
  marketing_calendar/ingest_date=YYYY-MM-DD/run_id=<run_id>/marketing_calendar.json
  promotions_calendar/ingest_date=YYYY-MM-DD/run_id=<run_id>/promotions_calendar.json


**Convenciones**

Metadatos técnicos: solo en _control (los JSON de datos quedan “puros”).
run_id recomendado: YYYYMMDDTHHMMSSZ_<uuid_short> (ej. 20260126T183000Z_a13f9c).
_control (mínimo)
run_manifest.json: puntero a ficheros + counts + timestamps + schema_version.
run_stats.json: tiempos por endpoint, tamaños, totales (opcional pero útil).
run_errors.json: errores/reintentos si aplica.


Notas de diseño:
Particiono por ingest_date para facilitar búsquedas/retención.
run_id cuelga dentro de cada endpoint para auditoría granular.
_control centraliza el “sobre” del run (muy útil cuando algo falla o para reproducibilidad).



PASO 2: Esquemas RAW (JSON plano) + versionado

2.1. Regla general de formato (aplica a todos los endpoints)

Cada fichero JSON tendrá esta estructura:

{"schema_version": "1.0",
  "endpoint": "orders",
  "extracted_at_utc": "2026-01-26T18:30:00Z",
  "records": [ ... ]}

schema_version: versión del “contrato” de datos RAW.
records: lista de objetos planos (sin anidaciones).


2.2. Schemas por endpoint (v1.0)
A) orders.json (base para fact_orders)
records[]
order_id (int)
order_date (string ISO: YYYY-MM-DD)
customer_id (int)
channel_id (int)
order_status (string) — valores: paid | cancelled | pending
total_tax_excl (number)
is_new_customer (0/1)
main_category_id (int)
main_product_id (int)

orders.json: incluye order_status con paid/cancelled/pending (la métrica usará solo paid en DW).


B) customers.json (base para dim_customer)

records[]
customer_id (int)
first_purchase_date (string ISO YYYY-MM-DD)
customer_type (string) — new | returning
country (string) — ISO2 

C) products.json (base para dim_product)

records[]
product_id (int)
product_name (string)
category_id (int)
base_price (number)

D) categories.json (base para dim_category)

records[]
category_id (int)
category_name (string)

E) channels.json (base para dim_channel)

records[]
channel_id (int)
channel_name (string) — web | mobile

F) marketing_calendar.json (variable exógena diaria)

records[]
date (string ISO YYYY-MM-DD)
campaña_marketing_activa (0/1)

G) promotions_calendar.json (variable exógena diaria)

records[]
date (string ISO YYYY-MM-DD)
hay_promocion (0/1)



2.4. Versionado (schema_version)

Arrancamos con 1.0.
Si añadimos campos sin romper compatibilidad: 1.1, 1.2.
Si cambiamos nombres/tipos o semántica: 2.0.


Paso 3: diseño del DW en Fabric 

El DW es el único punto de consumo para: PowerBI, MCP, modelo predictivo
Se implementa en Fabric, usando tablas Delta
Entrarán: modelo estrella de negocio, dimensión tiempo y las tablas de predicción


3.3. Dimensiones
dim_date (1 fila por día)

Campos:

date_id (PK, int) → YYYYMMDD
date (date)
year
quarter
month
month_name
week_of_year
day_of_month
day_of_week
day_name
is_weekend (0/1)

Se genera internamente en el DW. Es la única definición temporal para Power BI y MCP.

dim_customer
Origen RAW: customers.json
Campos:
customer_id (PK)
first_purchase_date
customer_type (new / returning)
country (ISO2)

dim_product
Origen RAW: products.json
Campos:
product_id (PK)
product_name
category_id (FK)
base_price

dim_category
Origen RAW: categories.json
Campos:
category_id (PK)
category_name

dim_channel
Origen RAW: channels.json
Campos:
channel_id (PK)
channel_name (web / mobile)

3.4. Tabla de hechos
fact_orders (1 fila por pedido)
Campos:
order_id (PK)
order_date_id (FK → dim_date.date_id)
customer_id (FK)
channel_id (FK)
main_product_id (FK)
main_category_id (FK)
order_status
total_tax_excl
is_new_customer (0/1)

3.5. Variables exógenas (tablas auxiliares)

fact_marketing_calendar (1 fila por día)
Campos:
date_id (FK → dim_date)
campaña_marketing_activa (0/1)

fact_promotions_calendar 1 fila por día
Campos:
date_id (FK → dim_date)
hay_promocion (0/1)


3.6. Tablas analíticas para predicción
pred_daily_sales 1 fila por día (histórico)
Campos:
date_id
date
total_sales_tax_excl
num_orders
hay_promocion
campaña_marketing_activa

Tabla derivada del modelo estrella + calendarios.
pred_sales_forecast 1 fila por día futuro
Campos:
date_id
date
forecast_sales_tax_excl
model_version
forecast_generated_at

3.7. Relaciones (modelo estrella)

fact_orders → dim_date
fact_orders → dim_customer
fact_orders → dim_product
fact_orders → dim_category
fact_orders → dim_channel
fact_marketing_calendar → dim_date
fact_promotions_calendar → dim_date
pred_* → dim_date


Paso 4: Mapeo RAW --> DW

4.2. Mapeo por tabla
dim_customer
Origen: customers.json
Reglas:
Carga 1:1 (sin deduplicación avanzada).
customer_id único.
Mapeo:
customer_id ← customer_id
first_purchase_date ← first_purchase_date
customer_type ← customer_type
country ← country (ISO2)

dim_category
Origen: categories.json
Reglas: carga directa.
Mapeo:
category_id ← category_id
category_name ← category_name

dim_product
Origen: products.json
Reglas:
category_id debe existir en dim_category.
Mapeo:
product_id ← product_id
product_name ← product_name
category_id ← category_id
base_price ← base_price

dim_channel
Origen: channels.json
Reglas: valores controlados (web, mobile).
Mapeo:
channel_id ← channel_id
channel_name ← channel_name

dim_date
Origen: generado en DW
Reglas:
Rango: histórico completo + 90 días futuros.
date_id = YYYYMMDD.

fact_orders
Origen: orders.json
Todas las FKs deben existir:
customer_id
channel_id
main_product_id
main_category_id
order_date debe existir en dim_date.
Mapeo:
order_id ← order_i
order_date_id ← order_date → dim_date.date_id
customer_id ← customer_id
channel_id ← channel_id
main_product_id ← main_product_id
main_category_id ← main_category_id
order_status ← order_status
total_tax_excl ← total_tax_excl
is_new_customer ← is_new_customer

fact_marketing_calendar
Origen: marketing_calendar.json
Reglas: 1 fila por día.
Mapeo:
date_id ← date → dim_date.date_id
campaña_marketing_activa ← campaña_marketing_activa

fact_promotions_calendar
Origen: promotions_calendar.json
Reglas: 1 fila por día.
Mapeo:
date_id ← date → dim_date.date_id
hay_promocion ← hay_promocion

4.3. Tablas de predicción (derivadas)
pred_daily_sales
Origen: fact_orders + calendarios
Campos:
date_id
date
total_sales_tax_excl = SUM(total_tax_excl)
num_orders = COUNT(order_id)
hay_promocion
campaña_marketing_activa

pred_sales_forecast
Origen: modelo predictivo
Reglas:
90 días futuros.
Versionado de modelo obligatorio.
Campos:
date_id
date
forecast_sales_tax_excl
model_version
forecast_generated_at

4.4. Checks de calidad (documentados)
Integridad
% de pedidos rechazados por FK inexistente = 0% esperado.
Días sin calendario = 0.
Negocio
total_tax_excl ≥ 0.
Ventas solo desde paid.
Cobertura
Histórico continuo (sin huecos de fechas).


Estado final
 Paso 1: Jerarquía RAW cerrada
 Paso 2: Schemas RAW + versionado cerrados
 Paso 3: Diseño del DW (modelo estrella + predicción) cerrado
 Paso 4: Contrato RAW → DW cerrado

Próximo paso: generación de datos
datos generados script por python, carpeta en escritorio
proximos pasos:
 - subir la carpeta raw/ al DL
 - Verificar que la ruta final es: /raw/prestashop/...
 - Validar que el run_manifest.json está accesible
 - A partir de ahí, empezar la carga al DW



